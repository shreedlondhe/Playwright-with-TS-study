1)What is Test Isolation in Playwright?
Answer:
Test isolation in Playwright means every test runs in a fresh browser context with its own cookies, localStorage, and session, ensuring tests do not interfere with each other.
No shared cookies 
[Cookies = small data sent with every HTTP request,Stored by browser,Automatically sent to server,Used for authentication & sessions,Have expiry
Use : Login session,Auth tokens]
No shared local storage
[LocalStorage = browser-side storage only,Stores data as key–value pairs,Not sent to server,No expiry (until cleared),Accessible via JavaScript]
No shared cache
[Cache = stored website resources,Stores static files,Improves page load speed,]

2)How Playwright Achieves Test Isolation
Answer:
By default, Playwright Test:
Launches one Browser
Creates a new BrowserContext per test
Creates a new Page per test

3) What is Playwright?
Answer:
Playwright is an end-to-end automation framework by Microsoft used to test web applications.
It supports Chromium, Firefox, and WebKit with a single API.

4) Why Playwright over Selenium?
Answer:
Auto-waiting (no need for explicit waits),support Video recording.
Faster execution
Supports multiple browsers & tabs
Better handling of modern web apps (SPA)
Built-in test runner

5) Why TypeScript is preferred with Playwright?
Answer:
Compile-time error checking
Strong typing (Locator, Page, Browser)
Better IDE support (auto-complete)
Fewer runtime errors

6) Difference between page ,context and  browser?
Answer:
Browser = actual browser instance [Examples: Chromium, Chrome, Firefox, WebKit]
BrowserContext = isolated user session [Like an Incognito window]
Page = a single tab

7) Real Playwright Test Example
Answer:
test('browser vs context vs page', async ({ browser }) => {
  const context = await browser.newContext();
  const page = await context.newPage();

  await page.goto('https://example.com');
});

8) Why does Playwright use BrowserContext instead of launching a new browser for every test?
Answer:
Launching a browser is expensive and slow.
BrowserContext provides a lightweight, isolated session (like incognito) that gives test isolation without restarting the browser, making tests faster and more scalable.

9) Can two pages share cookies?
Answer:
✅ Yes, if they belong to the same BrowserContext
❌ No, if they belong to different BrowserContexts

10) Can two BrowserContexts share data?
Answer:
❌ No.
Each BrowserContext is fully isolated — cookies, localStorage, cache are not shared.

11) How do you handle multiple tabs in Playwright?
Answer:
const pages = context.pages();
const secondTab = pages[1];
await secondTab.bringToFront();

12) Difference between browser.newPage() and context.newPage()?
Answer:
_________________________________________________________________
| Method              | Result                                   |
| ------------------- | ---------------------------------------- |
| `browser.newPage()` | Creates **new context + page**           |
| `context.newPage()` | Creates **page inside existing context** |
------------------------------------------------------------------

13) How does Playwright achieve test isolation?
Answer:
By creating a new BrowserContext per test, Playwright ensures:
Clean cookies
No shared localStorage
Reliable parallel execution

14) Can you run tests in parallel using one browser?
Answer:
✅ Yes.
One browser → multiple contexts → parallel tests.

15) How do you wait for an element to be visible?
Answer:
await page.locator('#login').waitFor({ state: 'visible' });

16) How do you handle alerts / dialogs?
Answer:
page.on('dialog', async dialog => {
  console.log(dialog.message());
  await dialog.accept(); // or dialog.dismiss()
});

17) How do you upload a file?
Answer:
await page.setInputFiles('#upload', 'tests/data/file.pdf');

18) How do you take a screenshot?
Answer:
await page.screenshot({ path: 'screenshot.png', fullPage: true });

19) How do you handle frames (iframe)?
Answer:
const frame = page.frameLocator('#frameId');
await frame.locator('#btn').click();

20) How do you mock API response?
Answer:
await page.route('**/api/users', route =>
  route.fulfill({
    status: 200,
    body: JSON.stringify({ name: 'Shrinivas' })
  })
);

21) What is test.use()?
Answer:
Used to apply settings per test or per file
test.use({ browserName: 'chromium' });

22) Difference between Locator and ElementHandle?
Answer:
Locator	                       ElementHandle
Auto-wait	                  ❌ No auto-wait
Recommended	              ❌ Not recommended
Lazy evaluation	              Immediate

23) How do you get text from element?
Answer:
const text = await page.locator('#msg').textContent();

24) Common assertions for elements
Answer:
await expect(locator).toBeVisible();
await expect(locator).toBeEnabled();
await expect(locator).toBeChecked();
await expect(locator).toHaveText('Login');

25) How to take screenshots on failure?
Answer:
Configured in playwright.config.ts
use: {
  screenshot: 'only-on-failure',
}

26)What are fixtures in Playwright?
Definition:
A fixture in Playwright is a pre-configured resource that is automatically created before a test and cleaned up after the test.
Key points:
            Helps reuse setup code.
            Ensures test isolation (each test gets its own instance).
            Supports automatic cleanup
Playwright comes with several built-in fixtures that you can use directly in your tests: page,browser,browserContext,request,workInfo

27)What are locators in Playwright?
Answer:
In Playwright, locators are a powerful way to identify and interact with elements on a web page.
const element =await page.locator(selector);

28)Explain the difference between locator.click() and page.click()?
Answer:
Use locator.click() instead of page.click() because locators provide better auto-waiting, retry logic, and stability for modern dynamic web applications.
locator.click()->first declare locator and then click (auto-waits, retries, and handles dynamic DOM)
page.click()->passing locator while clicking (is a one-time action and can be flaky)

29) How do you launch a browser in Playwright?
Answer:
const browser = await chromium.launch({ headless: false });

30) What is auto-waiting in Playwright?
Answer:
Playwright automatically waits for:
Element to appear
Visibility
Enablement
Stability

31)What is test.describe()?
Answer:
Used to group related test cases.
test.describe('Login Tests', () => {
  test('valid login', async () => {});
});

32)What is expect in Playwright?

Answer:
expect is an assertion library used to validate test results.

await expect(page).toHaveTitle('Home');

33)What is beforeEach and afterEach?
Answer:
beforeEach runs before every test
afterEach runs after every test

34)What is BrowserContext? Why is it important?
Answer:
BrowserContext is an isolated browser session similar to an incognito window.
Importance:
Separate cookies & cache
Enables parallel execution
Improves security testing

35)How do you handle file upload?
Answer:
await page.setInputFiles('#upload', 'file.pdf');

36)What is an ElementHandle in Playwright?
Answer:
In Playwright, an ElementHandle is a reference (handle) to a specific DOM element on the page.
It represents one particular element at a specific point in time.
const elementHandle = await page.$('#username'); // page.$('#username') returns an ElementHandle
await elementHandle?.fill('Shrinivas');

40)Difference between Locator and ElementHandle?
Answer:
Locator	      ElementHandle
Auto-waits	❌ No
Retry logic	❌ No
DOM-safe	❌ No
Recommended	❌ No

41)How do you handle file download?
Answer:
const download = await page.waitForEvent('download');
await download.saveAs('report.pdf');

42)How do you handle multiple tabs or windows?
Answer:
const [newPage] = await Promise.all([
  context.waitForEvent('page'),
  page.click('#openTab')
]);

43)How do you debug Playwright tests?
Answer:
npx playwright test --debug

44)What is Trace Viewer?
Answer:
Trace Viewer records:
DOM snapshots
Network logs
Screenshots
Actions timeline
Helps in root cause analysis.

45)How do you integrate Allure reports?
Answer:
npm install -D allure-playwright

46)How do you handle environment variables?
Answer:
Using .env file:
process.env.BASE_URL

47)How do you retry failed tests?
Answer:
retries: 2

48)What is soft assertion in Playwright?
Answer:
Soft assertions allow test to continue even if assertion fails.
await expect.soft(locator).toBeVisible();

49)How do you handle network mocking?
Answer:
await page.route('**/api/**', route =>
  route.fulfill({ status: 200, body: JSON.stringify(mockData) })
);

50)What is the default timeout in Playwright?
Answer:
Test timeout: 30 seconds
Action timeout: 0 (relies on auto-wait)
Expect timeout: 5 seconds

51)Difference between timeout and expect.timeout?
Answer:
timeout	                      expect.timeout
Test-level	           Assertion-level
Stops entire test	   Only waits for assertion
Configurable globally 	   Configurable per expect

52)What is locator.all()?
Answer:
Returns all matching elements as an array of locators.
const items = await page.locator('.row').all();

53)What is locator.first() / locator.last()?
Answer:
Used to resolve strict mode when multiple elements exist.
locator.first()
locator.last()

54)How do you handle Alerts & Dialogs?
Answer:
Using dialog event.
page.on('dialog', dialog => dialog.accept());

55)How do you handle frames / iframes?
Answer:
Using frameLocator().
await page.frameLocator('#frame').locator('#btn').click();

56)Explain the internal architecture of Playwright
Answer:
Playwright uses a client–server architecture.
Test code runs in Node.js
Playwright communicates with browsers using WebSocket
Each browser runs in a separate process
Actions are sent as protocol commands
Supports Chromium, Firefox, WebKit via a unified API

57)When do you use multiple browser contexts?
Answer:
Multiple browser contexts are used when:
Testing multiple users in parallel
Running isolated sessions
Verifying role-based access
Preventing cookie/session conflicts
Each context behaves like an incognito window.

58)What is Playwright Test Generator?
Answer:
A tool that records user actions and generates Playwright test code.
npx playwright codegen

59)Difference between Promise and Promise.all()
Answer:
Promise:
Promise represents one asynchronous operation that will complete in the future.
States of Promise:
                  Pending
                  Fulfilled
                  Rejected

Example
const promise = new Promise((resolve, reject) => {	`
  setTimeout(() => {
    resolve('Data loaded');
  }, 1000);
});
promise.then(result => console.log(result));

Promise.all():
Promise.all() is used to run multiple promises in parallel and wait until all of them are resolved.
Example
const p1 = Promise.resolve(10);
const p2 = Promise.resolve(20);
const p3 = Promise.resolve(30);
const result = await Promise.all([p1, p2, p3]);
console.log(result); 

60)Test randomly fails — how do you debug Playwright tests?
Approach:
Enable trace, video, screenshots
Run in headed mode
Use DEBUG=pw:api
Identify missing waits / wrong locator strategy

61)Login test takes time — how do you speed it up?
Answer:
Best Practice: Storage State
// global-setup.ts
await page.goto('/login');
await page.fill('#user', 'admin');
await page.fill('#pass', 'pwd');
await page.click('#login');
await page.context().storageState({ path: 'auth.json' });

62)How do you handle flaky tests?
Answer: 
Use auto-waiting locators
Replace waitForTimeout
Add retries only for flaky tests

63)How do you download a file & verify contents?
Answer: 
const [download] = await Promise.all([
  page.waitForEvent('download'),
  page.click('#download')
]);

const path = await download.path();

Verify content:
import * as fs from 'fs';
expect(fs.readFileSync(path!).toString()).toContain('Invoice');

64)How do you delete test artifacts after test completion?
Answer: 
test.afterEach(() => {
  fs.rmSync('temp.txt', { force: true });
});

65)How do you pass test data from Excel / JSON?
JSON
Answer: 
import data from '../data/users.json';
await page.fill('#user', data.username);
import ExcelJS from 'exceljs';
const workbook = new ExcelJS.Workbook();
await workbook.xlsx.readFile('data.xlsx');

66)How do you wait for network calls?
Answer:
await page.waitForResponse(resp =>
  resp.url().includes('/api/order') && resp.status() === 200
);

67)How to handle dynamic elements?
Answer:
Text-based locators
Regex

68)Types of waits?
Answer:
Auto wait (default)
Explicit (toBeVisible)
Network waits
Load state

69)playwright.config.ts purpose?
Answer:
Browser config
Parallel execution
Retry
Reporters
Env setup

70)What is StorageState?
Answer:
Saves cookies & localStorage to reuse authenticated session.

71)Flaky tests — how do you handle?
Answer:
Remove hard waits
Use proper locators
Retry logic
Trace viewer

72)OTP automation?
Answer:
handle via API OTP

73)What happens if locator matches multiple elements?
Answer:
Playwright throws strict mode violation

74)How do you disable strict mode?
Answer:
Not recommended, but possible:
page.locator('button').first().click();

75)Difference between waitForSelector and locator?
Answer:
| waitForSelector | locator         |
| --------------- | --------------- |
| Manual wait     | Auto-wait       |
| Returns element | Action-oriented |

76)When does waitForNavigation fail?
Answer:
When navigation happens before wait is registered
Solution:
await Promise.all([
  page.waitForNavigation(),   
  page.click('#submit')
]);

77)networkidle vs load vs domcontentloaded?
Answer:
State                   	Meaning
domcontentloaded	      HTML loaded
load	                      CSS + images
networkidle          	     No network calls

78)How do you handle new tab? 
Answer:
const [newPage] = await Promise.all([
  context.waitForEvent('page'),
  page.click('#open')
]);

79)Can Playwright read DB?
Answer:
Not directly. Use Node DB client.

90)How do you share API context across tests?
Answer:
const apiContext = await request.newContext();

91)Where do you write reusable logic?
Answer:
utils/
fixtures/
helpers/

92)
















